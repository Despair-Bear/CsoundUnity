<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CsoundUnity: csoundUnityClass</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CsoundUnity<span id="projectnumber">&#160;3.2.0</span>
   </div>
   <div id="projectbrief">Csound wrapper for the Unity game engine.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">csoundUnityClass </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >/// Send a score event to <a class="el" href="namespace_csound.html">Csound</a> in the form of "i1 0 10 ....
/// &lt;/summary&gt;

&lt;tt&gt;public int GetVersion()&lt;/tt&gt;

Returns the Csound version number times 1000 (5.00.0 = 5000).

&lt;tt&gt;public int GetAPIVersion()&lt;/tt&gt;

Returns the Csound API version number times 100 (1.00 = 100).

&lt;tt&gt;public bool CompiledWithoutError()&lt;/tt&gt;

Returns true if the csd file was compiled without errors.

&lt;tt&gt;public void SetCsd(string guid)&lt;/tt&gt;

Sets the csd file

&lt;tt&gt;public int CompileOrc(string orcStr)&lt;/tt&gt;

Parse, and compile the given orchestra from an ASCII string,
also evaluating any global space code (i-time only)
this can be called during performance to compile a new orchestra.

This sample shows how to use CompileOrc

@code{cs} 
string orc = "instr 1 <br  />
 a1 rand 0dbfs/4 <br  />
 out a1 \nendin<br  />
";
CompileOrc(orc);
@endcode


///
/// &lt;param name="scoreEvent"&gt;the score string to send&lt;/param&gt;
public void SendScoreEvent(string scoreEvent)
{
    //print(scoreEvent);
    csound.SendScoreEvent(scoreEvent);
}

/// 
&lt;summary&gt;
/// Rewinds a compiled Csound score to the time specified with SetScoreOffsetSeconds().
/// &lt;/summary&gt;
public void RewindScore()
{
    csound.RewindScore();
}

/// 
&lt;summary&gt;
/// Csound score events prior to the specified time are not performed,
/// and performance begins immediately at the specified time
/// (real-time events will continue to be performed as they are received).
/// Can be used by external software, such as a VST host, to begin score performance midway through a Csound score,
/// for example to repeat a loop in a sequencer, or to synchronize other events with the Csound score.
/// &lt;/summary&gt;
/// &lt;param name="value"&gt;&lt;/param&gt;
public void SetScoreOffsetSeconds(MYFLT value)
{
    csound.CsoundSetScoreOffsetSeconds(value);
}

/// 
&lt;summary&gt;
/// Get the current sample rate
/// &lt;/summary&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public MYFLT GetSr()
{
    return csound.GetSr();
}

/// 
&lt;summary&gt;
/// Get the current control rate
/// &lt;/summary&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public MYFLT GetKr()
{
    return csound.GetKr();
}

/// 
&lt;summary&gt;
/// Process a ksmps-sized block of samples
/// &lt;/summary&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public int PerformKsmps()
{
    return csound.PerformKsmps();
}

/// 
&lt;summary&gt;
/// Get the current control rate
/// &lt;/summary&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public uint GetKsmps()
{
    return csound.GetKsmps();
}

#endregion PERFORMANCE

#region CSD_PARSE

/// 
&lt;summary&gt;
/// Parse the csd and returns available audio channels (set in csd via: &lt;code&gt;chnset avar, "audio channel name") &lt;/code&gt;
/// &lt;/summary&gt;
/// &lt;param name="filename"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static List&lt;string&gt; ParseCsdFileForAudioChannels(string filename)
{
    if (!File.Exists(filename)) return null;

    string[] fullCsdText = File.ReadAllLines(filename);
    if (fullCsdText.Length &lt; 1) return null;

    List&lt;string&gt; locaAudioChannels = new List&lt;string&gt;();

    foreach (string line in fullCsdText)
    {
        var trimmd = line.TrimStart();
        if (!trimmd.Contains("chnset")) continue;
        if (trimmd.StartsWith(";")) continue;
        var lndx = trimmd.IndexOf("chnset");
        var chnsetEnd = lndx + "chnset".Length + 1;
        var prms = trimmd.Substring(chnsetEnd, trimmd.Length - chnsetEnd);
        var split = prms.Split(',');
        if (!split[0].StartsWith("a") &amp;&amp; !split[0].StartsWith("ga"))
            continue; //discard non audio variables
        // Debug.Log("found audio channel");
        var ach = split[1].Replace('\\', ' ').Replace('\"', ' ').Trim();
        if (!locaAudioChannels.Contains(ach))
            locaAudioChannels.Add(ach);
    }
    return locaAudioChannels;
}

/// 
&lt;summary&gt;
/// Parse the csd file
/// &lt;/summary&gt;
/// &lt;param name="filename"&gt;the csd file to parse&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static List&lt;CsoundChannelController&gt; ParseCsdFile(string filename)
{
    if (!File.Exists(filename)) return null;

    string[] fullCsdText = File.ReadAllLines(filename);
    if (fullCsdText.Length &lt; 1) return null;

    List&lt;CsoundChannelController&gt; locaChannelControllers;
    locaChannelControllers = new List&lt;CsoundChannelController&gt;();

    foreach (string line in fullCsdText)
    {
@verbatim 
if (line.Contains("&lt;/"))
    break;

var trimmd = line.TrimStart();
//discard csound comments in cabbage widgets
if (trimmd.StartsWith(";"))
{
    //Debug.Log("discarding "+line);
    continue;
}
string newLine = trimmd;
string control = trimmd.Substring(0, trimmd.IndexOf(" ") &gt; -1 ? trimmd.IndexOf(" ") : 0);
if (control.Length &gt; 0)
    newLine = newLine.Replace(control, "");

if (control.Contains("slider") || control.Contains("button") || control.Contains("checkbox")
    || control.Contains("groupbox") || control.Contains("form") || control.Contains("combobox"))
{
    CsoundChannelController controller = new CsoundChannelController();
    controller.type = control;

    if (trimmd.IndexOf("caption(") &gt; -1)
    {
        string infoText = trimmd.Substring(trimmd.IndexOf("caption(") + 9);
        infoText = infoText.Substring(0, infoText.IndexOf(")") - 1);
        controller.caption = infoText;
    }

    if (trimmd.IndexOf("text(") &gt; -1)
    {
        string text = trimmd.Substring(trimmd.IndexOf("text(") + 6);
        text = text.Substring(0, text.IndexOf(")") - 1);
        text = text.Replace(""", "");
        text = text.Replace('"', new char()); if (controller.type == "combobox") //if combobox, create a range { char[] delimiterChars = { ',' }; string[] tokens = text.Split(delimiterChars); controller.SetRange(1, tokens.Length, 0);</p>
<p >for (var o = 0; o &lt; tokens.Length; o++) { tokens[o] = string.Join("", tokens[o].Split(default(string[]), System.StringSplitOptions.RemoveEmptyEntries)); } controller.options = tokens; } }</p>
<p >if (trimmd.IndexOf("items(") &gt; -1) { string text = trimmd.Substring(trimmd.IndexOf("items(") + 7); text = text.Substring(0, text.IndexOf(")") - 1); //TODO THIS OVERRIDES TEXT! text = text.Replace("\"", ""); text = text.Replace('"', new char()); if (controller.type == "combobox") { char[] delimiterChars = { ',' }; string[] tokens = text.Split(delimiterChars); controller.SetRange(1, tokens.Length, 0);</p>
<p >for (var o = 0; o &lt; tokens.Length; o++) { tokens[o] = string.Join("", tokens[o].Split(default(string[]), System.StringSplitOptions.RemoveEmptyEntries)); } controller.options = tokens; } }</p>
<p >if (trimmd.IndexOf("channel(") &gt; -1) { string channel = trimmd.Substring(trimmd.IndexOf("channel(") + 9); channel = channel.Substring(0, channel.IndexOf(")") - 1); controller.channel = channel; }</p>
<p >if (trimmd.IndexOf("range(") &gt; -1) { int rangeAt = trimmd.IndexOf("range("); if (rangeAt != -1) { string range = trimmd.Substring(rangeAt + 6); range = range.Substring(0, range.IndexOf(")")); char[] delimiterChars = { ',' }; string[] tokens = range.Split(delimiterChars); for (var i = 0; i &lt; tokens.Length; i++) { tokens[i] = string.Join("", tokens[i].Split(default(string[]), StringSplitOptions.RemoveEmptyEntries)); if (tokens[i].StartsWith(".")) { tokens[i] = "0" + tokens[i]; } if (tokens[i].StartsWith("-.")) { tokens[i] = "-0" + tokens[i].Substring(2, tokens[i].Length - 2); } } var min = float.Parse(tokens[0], CultureInfo.InvariantCulture); var max = float.Parse(tokens[1], CultureInfo.InvariantCulture); var val = float.Parse(tokens[2], CultureInfo.InvariantCulture); controller.SetRange(min, max, val); } }</p>
<p >if (line.IndexOf("value(") &gt; -1) { string value = trimmd.Substring(trimmd.IndexOf("value(") + 6); value = value.Substring(0, value.IndexOf(")")); value = value.Replace("\"", ""); controller.value = value.Length &gt; 0 ? float.Parse(value, CultureInfo.InvariantCulture) : 0; if (control.Contains("combobox")) { //Cabbage combobox index starts from 1 controller.value = controller.value - 1; // Debug.Log("combobox value in parse: " + controller.value); } } locaChannelControllers.Add(controller); }  } return locaChannelControllers; }</p>
<p >#endregion CSD_PARSE</p>
<p >#region IO_BUFFERS</p>
<p >/// </p>
<p >/// Set a sample in <a class="el" href="namespace_csound.html">Csound</a>'s input buffer /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>public void SetInputSample(int frame, int channel, MYFLT sample) { csound.SetSpinSample(frame, channel, sample); }</p>
<p >/// </p>
<p >/// Adds the indicated sample into the audio input working buffer (spin); /// this only ever makes sense before calling PerformKsmps(). /// The frame and channel must be in bounds relative to ksmps and nchnls. /// NB: the spin buffer needs to be cleared at every k-cycle by calling ClearSpin(). /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>public void AddInputSample(int frame, int channel, MYFLT sample) { csound.AddSpinSample(frame, channel, sample); }</p>
<p >/// </p>
<p >/// Clears the input buffer (spin). /// </p>
<p >public void ClearSpin() { if (csound != null) { Debug.Log("clear spin"); csound.ClearSpin(); } }</p>
<p >/// </p>
<p >/// Get a sample from <a class="el" href="namespace_csound.html">Csound</a>'s audio output buffer /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public MYFLT GetOutputSample(int frame, int channel) { return csound.GetSpoutSample(frame, channel); }</p>
<p >/// </p>
<p >/// Get <a class="el" href="namespace_csound.html">Csound</a>'s audio input buffer /// </p>
<p >/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public MYFLT[] GetSpin() { return csound.GetSpin(); }</p>
<p >/// </p>
<p >/// Get <a class="el" href="namespace_csound.html">Csound</a>'s audio output buffer /// </p>
<p >/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public MYFLT[] GetSpout() { return csound.GetSpout(); }</p>
<p >#endregion IO_BUFFERS</p>
<p >#region CONTROL_CHANNELS /// </p>
<p >/// Sets a <a class="el" href="namespace_csound.html">Csound</a> channel. Used in connection with a chnget opcode in your <a class="el" href="namespace_csound.html">Csound</a> instrument. /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>public void SetChannel(string channel, MYFLT val) { csound.SetChannel(channel, val); }</p>
<p >/// </p>
<p >/// Sets a string channel in <a class="el" href="namespace_csound.html">Csound</a>. Used in connection with a chnget opcode in your <a class="el" href="namespace_csound.html">Csound</a> instrument. /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>public void SetStringChannel(string channel, string val) { csound.SetStringChannel(channel, val); }</p>
<p >/// </p>
<p >/// Gets a <a class="el" href="namespace_csound.html">Csound</a> channel. Used in connection with a chnset opcode in your <a class="el" href="namespace_csound.html">Csound</a> instrument. /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public MYFLT GetChannel(string channel) { return csound.GetChannel(channel); }</p>
<p >/// </p>
<p >/// blocking method to get a list of the channels from <a class="el" href="namespace_csound.html">Csound</a>, not from the serialized list of this instance /// </p>
<p >/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public IDictionary&lt;string, CsoundUnityBridge.ChannelInfo&gt; GetChannelList() { return csound.GetChannelList(); }</p>
<p >#endregion CONTROL_CHANNELS</p>
<p >#region AUDIO_CHANNELS</p>
<p >/// </p>
<p >/// Gets a <a class="el" href="namespace_csound.html">Csound</a> Audio channel. Used in connection with a chnset opcode in your <a class="el" href="namespace_csound.html">Csound</a> instrument. /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public MYFLT[] GetAudioChannel(string channel) { return csound.GetAudioChannel(channel); }</p>
<p >#endregion AUDIO_CHANNELS</p>
<p >#region TABLES</p>
<p >/// </p>
<p >/// Creates a table with the supplied samples. /// Can be called during performance. /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableNumber</td><td>The table number</td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public int CreateTable(int tableNumber, MYFLT[] samples/*, int nChannels*/) { if (samples.Length &lt; 1) return -1; var resTable = CreateTableInstrument(tableNumber, samples.Length); if (resTable != 0) return -1; // copy samples to the newly created table CopyTableIn(tableNumber, samples);</p>
<p >return resTable; }</p>
<p >/// </p>
<p >/// Creates an empty table, to be filled with samples later. /// Please note that trying to read the samples from an empty folder will produce a crash. /// Can be called during performance. /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableNumber</td><td>The number of the newly created table</td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableLength</td><td>The length of the table in samples</td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="section return"><dt>Returns</dt><dd>0 If the table could be created</dd></dl>
<p>public int CreateTableInstrument(int tableNumber, int tableLength/*, int nChannels*/) { string createTableInstrument = String.Format("gisampletable{0} ftgen {0}, 0, {1}, -7, 0, 0", tableNumber, -tableLength /** AudioSettings.outputSampleRate*/);
    // Debug.Log("orc to create table: <br  />
" + createTableInstrument);
    return CompileOrc(createTableInstrument);
}

/// 
&lt;summary&gt;
/// Returns the length of a function table (not including the guard point), or -1 if the table does not exist.
/// &lt;/summary&gt;
/// &lt;param name="table"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public int GetTableLength(int table)
{
    return csound.TableLength(table);
}

/// 
&lt;summary&gt;
/// Retrieves a single sample from a Csound function table.
/// &lt;/summary&gt;
/// &lt;param name="tableNumber"&gt;&lt;/param&gt;
/// &lt;param name="index"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public MYFLT GetTableSample(int tableNumber, int index)
{
    return csound.GetTable(tableNumber, index);
}

/// 
&lt;summary&gt;
/// Stores values to function table 'numTable' in tableValues, and returns the table length (not including the guard point).
/// If the table does not exist, tableValues is set to NULL and -1 is returned.
/// &lt;/summary&gt;
/// &lt;param name="tableValues"&gt;&lt;/param&gt;
/// &lt;param name="numTable"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public int GetTable(out MYFLT[] tableValues, int numTable)
{
    return csound.GetTable(out tableValues, numTable);
}

/// 
&lt;summary&gt;
/// Stores the arguments used to generate function table 'tableNum' in args, and returns the number of arguments used.
/// If the table does not exist, args is set to NULL and -1 is returned.
/// NB: the argument list starts with the GEN number and is followed by its parameters.
/// eg. f 1 0 1024 10 1 0.5 yields the list {10.0,1.0,0.5}
/// &lt;/summary&gt;
/// &lt;param name="args"&gt;&lt;/param&gt;
/// &lt;param name="index"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public int GetTableArgs(out MYFLT[] args, int index)
{
    return csound.GetTableArgs(out args, index);
}

/// 
&lt;summary&gt;
/// Sets the value of a slot in a function table. The table number and index are assumed to be valid.
/// &lt;/summary&gt;
/// &lt;param name="table"&gt;&lt;/param&gt;
/// &lt;param name="index"&gt;&lt;/param&gt;
/// &lt;param name="value"&gt;&lt;/param&gt;
public void SetTable(int table, int index, MYFLT value)
{
    csound.SetTable(table, index, value);
}

/// 
&lt;summary&gt;
/// Copy the contents of a function table into a supplied array dest
/// The table number is assumed to be valid, and the destination needs to have sufficient space to receive all the function table contents.
/// &lt;/summary&gt;
/// &lt;param name="table"&gt;&lt;/param&gt;
/// &lt;param name="dest"&gt;&lt;/param&gt;
public void CopyTableOut(int table, out MYFLT[] dest)
{
    csound.TableCopyOut(table, out dest);
}

/// 
&lt;summary&gt;
/// Asynchronous version of copyTableOut
/// &lt;/summary&gt;
/// &lt;param name="table"&gt;&lt;/param&gt;
/// &lt;param name="dest"&gt;&lt;/param&gt;
public void CopyTableOutAsync(int table, out MYFLT[] dest)
{
    csound.TableCopyOutAsync(table, out dest);
}

/// 
&lt;summary&gt;
/// Copy the contents of a supplied array into a function table
/// The table number is assumed to be valid, and the destination needs to have sufficient space to receive all the function table contents.
/// &lt;/summary&gt;
/// &lt;param name="table"&gt;the number of the table&lt;/param&gt;
/// &lt;param name="source"&gt;the supplied array&lt;/param&gt;
public void CopyTableIn(int table, MYFLT[] source)
{
    csound.TableCopyIn(table, source);
}

/// 
&lt;summary&gt;
/// Asynchronous version of copyTableOut
/// &lt;/summary&gt;
/// &lt;param name="table"&gt;&lt;/param&gt;
/// &lt;param name="source"&gt;&lt;/param&gt;
public void CopyTableInAsync(int table, MYFLT[] source)
{
    csound.TableCopyInAsync(table, source);
}

/// 
&lt;summary&gt;
/// Checks if a given GEN number num is a named GEN if so, it returns the string length (excluding terminating NULL char)
/// Otherwise it returns 0.
/// &lt;/summary&gt;
/// &lt;param name="num"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public int IsNamedGEN(int num)
{
    return csound.IsNamedGEN(num);
}

/// 
&lt;summary&gt;
/// Gets the GEN name from a number num, if this is a named GEN
/// The final parameter is the max len of the string (excluding termination)
/// &lt;/summary&gt;
/// &lt;param name="num"&gt;&lt;/param&gt;
/// &lt;param name="name"&gt;&lt;/param&gt;
/// &lt;param name="len"&gt;</p>
<p >public void GetNamedGEN(int num, out string name, int len) { csound.GetNamedGEN(num, out name, len); }</p>
<p >/// </p>
<p >/// Returns a Dictionary keyed by the names of all named table generators. /// Each name is paired with its internal function number. /// </p>
<p >/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public IDictionary&lt;string, int&gt; GetNamedGens() { return csound.GetNamedGens(); }</p>
<p >#endregion TABLES</p>
<p >#region CALLBACKS</p>
<p >public void SetYieldCallback(Action callback) { </p><pre class="fragment">csound.SetYieldCallback(callback);
</pre><p> }</p>
<p >public void SetSenseEventCallback&lt;T&gt;(Action&lt;T&gt; action, T type) where T : class { csound.SetSenseEventCallback(action, type); }</p>
<p >public void AddSenseEventCallback(CsoundUnityBridge.Csound6SenseEventCallbackHandler callbackHandler) { csound.SenseEventsCallback += callbackHandler;//Csound_SenseEventsCallback; }</p>
<p >public void RemoveSenseEventCallback(CsoundUnityBridge.Csound6SenseEventCallbackHandler callbackHandler) { csound.SenseEventsCallback -= callbackHandler; }</p>
<p >#endregion CALLBACKS</p>
<p >#region UTILITIES</p>
<p >#if UNITY_EDITOR /// </p>
<p >/// A method that retrieves the current csd file path from its GUID /// </p>
<p >/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public string GetFilePath() { return Path.Combine(Application.dataPath.Substring(0, Application.dataPath.Length - "Assets".Length), AssetDatabase.GUIDToAssetPath(csoundFileGUID)); } #endif</p>
<p >public <a class="el" href="class_csound_unity_bridge_1_1_c_s_o_u_n_d___p_a_r_a_m_s.html">CsoundUnityBridge.CSOUND_PARAMS</a> GetParams() { return csound.GetParams(); }</p>
<p >public void SetParams(<a class="el" href="class_csound_unity_bridge_1_1_c_s_o_u_n_d___p_a_r_a_m_s.html">CsoundUnityBridge.CSOUND_PARAMS</a> parms) { csound.SetParams(parms); }</p>
<p >/// </p>
<p >/// Get Environment path /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envType</td><td>the type of the environment to get</td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public string GetEnv(EnvType envType) { return csound.GetEnv(envType.ToString()); }</p>
<p >//#if CSHARP_7_3_OR_NEWER // /// </p>
<p >// /// Get the Opcode List, async // /// </p>
<p >// /// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>// public async Task&lt;IDictionary&lt;string, IList&lt;CsoundUnityBridge.OpcodeArgumentTypes&gt;&gt;&gt; GetOpcodeListAsync() // { // return await csound.GetOpcodeListAsync(); // } //#endif</p>
<p >/// </p>
<p >/// Get the Opcode List, blocking /// </p>
<p >/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public IDictionary&lt;string, IList&lt;CsoundUnityBridge.OpcodeArgumentTypes&gt;&gt; GetOpcodeList() { return csound.GetOpcodeList(); }</p>
<p >/// </p>
<p >/// Get the number of input channels /// </p>
<p >/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public uint GetNchnlsInputs() { return csound.GetNchnlsInput(); }</p>
<p >/// </p>
<p >/// Get the number of output channels /// </p>
<p >/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public uint GetNchnls() { return csound.GetNchnls(); }</p>
<p >/// </p>
<p >/// Get 0 dbfs /// </p>
<p >/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public MYFLT Get0dbfs() { return csound.Get0dbfs(); }</p>
<p >/// </p>
<p >/// Returns the current performance time in samples /// </p>
<p >/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public long GetCurrentTimeSamples() { return csound.GetCurrentTimeSamples(); }</p>
<p >/// </p>
<p >/// map MYFLT within one range to another /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from1</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to1</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from2</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to2</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public static float Remap(float value, float from1, float to1, float from2, float to2) { float retValue = (value - from1) / (to1 - from1) * (to2 - from2) + from2; return Mathf.Clamp(retValue, from2, to2); }</p>
<p >/// </p>
<p >/// Get Samples from a path, specifying the origin of the path. This will return an interleaved /// array of samples, with the first index used to specify the number of channels. This array can /// be passed to the <a class="el" href="class_csound_unity.html#a02fad33460f51f304ead99509a7bd69d" title="Creates a table with the supplied samples. Can be called during performance.">CsoundUnity.CreateTable()</a> method for processing by <a class="el" href="namespace_csound.html">Csound</a>. Use async versions to /// to load very large files. /// /// Note: You need to be careful that your AudioClips match the SR of the /// project. If not, you will hear some re-pitching issues with your audio when /// you play it back with a table reader opcode. /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">async</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>/// public static MYFLT[] GetStereoSamples(string source, SamplesOrigin origin) { return GetSamples(source, origin, 0, true); }</p>
<p >public static MYFLT[] GetMonoSamples(string source, SamplesOrigin origin, int channelNumber) { return GetSamples(source, origin, channelNumber, true); } public static MYFLT[] GetSamples(string source, SamplesOrigin origin, int channelNumber = 1, bool writeChannelData = false) { MYFLT[] res = new MYFLT[0]; switch (origin) { case SamplesOrigin.Resources: var src = Resources.Load&lt;AudioClip&gt;(source); if (src == null) { res = null; break; } var data = new float[src.samples * src.channels]; src.GetData(data, 0);</p>
<p >if (writeChannelData) { res = new MYFLT[src.samples * src.channels + 1]; res[0] = src.channels; var s = 1; for (var i = 0; i &lt; data.Length; i++) { res[s] = data[i]; s++; } } else { var s = 0; res = new MYFLT[src.samples];</p>
<p >for (var i = 0; i &lt; data.Length; i += src.channels, s++) { res[s] = data[i + (channelNumber - 1)]; } } break; case SamplesOrigin.StreamingAssets: Debug.LogWarning("Not implemented yet"); break; case SamplesOrigin.Absolute: Debug.LogWarning("Not implemented yet"); break; }</p>
<p >return res; }</p>
<p >/// </p>
<p >/// Async version of GetSamples /// example of usage: /// </p><div class="fragment"><div class="line">/// yield return CsoundUnity.GetSamples(source.name, CsoundUnity.SamplesOrigin.Resources, (samples) =&gt;</div>
<div class="line">/// {</div>
<div class="line">///     Debug.Log(&quot;samples loaded: &quot;+samples.Length+&quot;, creating table&quot;);</div>
<div class="line">///     csound.CreateTable(100, samples);</div>
<div class="line">/// });</div>
<div class="line">/// </div>
</div><!-- fragment --><p> /// </p>
<p >/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the name of the AudioClip to load</td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>the origin of the path</td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">onSamplesLoaded</td><td>the callback when samples are loaded</td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>public static IEnumerator GetSamples(string source, SamplesOrigin origin, Action&lt;MYFLT[]&gt; onSamplesLoaded) { switch (origin) { case SamplesOrigin.Resources: //var src = Resources.Load&lt;AudioClip&gt;(source); var req = Resources.LoadAsync&lt;AudioClip&gt;(source);</p>
<p >while (!req.isDone) { yield return null; } var samples = ((AudioClip)req.asset).samples; if (samples == 0) { onSamplesLoaded?.Invoke(null); yield break; } //Debug.Log("src.samples: " + samples); var ac = ((AudioClip)req.asset); var data = new float[samples * ac.channels]; ac.GetData(data, 0); MYFLT[] res = new MYFLT[samples * ac.channels]; var s = 0; foreach (var d in data) { res[s] = (MYFLT)d; s++; } onSamplesLoaded?.Invoke(res); break; case SamplesOrigin.StreamingAssets: Debug.LogWarning("Not implemented yet"); break; case SamplesOrigin.Absolute: Debug.LogWarning("Not implemented yet"); break; }</p>
<p >}</p>
<p >#if UNITY_ANDROID</p>
<p >/**</p><ul>
<li><p class="startli">Android method to write csd file to a location it can be read from Method returns the file path. */ public string GetCsoundFile(string csoundFileContents) { try { Debug.Log("Csound file contents:"); Debug.Log(csoundFileContents); string filename = Application.persistentDataPath + "/csoundFile.csd"; Debug.Log("Writing to " + filename);</p>
<p class="startli">if (!File.Exists(filename)) { Debug.Log("File doesnt exist, creating it"); File.Create(filename).Close(); }</p>
<p class="startli">if (File.Exists(filename)) { Debug.Log("File has been created"); }</p>
<p class="startli">File.WriteAllText(filename, csoundFileContents); return filename; } catch (System.Exception e) { Debug.LogError("Error writing to file: " + e.ToString()); }</p>
</li>
</ul>
<p >return ""; }</p>
<p >public void GetCsoundAudioFile(byte[] data, string filename) { try { string name = Application.persistentDataPath + "/" + filename; File.Create(name).Close(); File.WriteAllBytes(name, data); } catch (System.Exception e) { Debug.LogError("Error writing to file: " + e.ToString()); } } </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
